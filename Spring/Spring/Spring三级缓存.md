如果A依赖于B，B依赖于A

思路：

现在创建ABean：

1. 实例化A，放入缓存
2. A依赖于B，查找B，没有B，开始实例化B
3. B依赖于A，这是已经存在A，可以被引用
4. B初始化成功
5. A引用B，A初始化成功
6. 至此AB都创建了对象

上述思路就可以解决Spring的循环依赖问题，也就是说解决Spring的循环依赖只需要一级缓存就可以解决

但是，现在我们所说的A和B这两个Bean只是原始对象，也就是没有被代理的对象，如果使用代理对象应该怎么办呢
通过第三级缓存，实际上是一个Bean工厂，在这里我们可以很容易的将有需要的原始对象加工成为代理对象

那为什么不直接使用Factory呢，这样就可以直接使用一个缓存对象而解决循环依赖的问题？

- 只使用一个缓存，缓存里面有完整的Bean，也有不完整的Bean，容易出现错误
- Bean的获取是由一级缓存到三级缓存，缓存Bean的时候是由第三级缓存到第一级缓存顺序保存



上面我们是对字段注入的解决，Spring循环依赖有三大场景

- 构造器注入
- 字段注入或者Set注入（单实例）
- prototype字段注入

我们能解决的只有字段注入，对于构造器注入和非单实例的Bean的注入我们是无法解决的

对于构造器注入，我们在实例化对象的时候就需要注入，因为循环依赖的问题，导致无法实例化。

对于Prototype类型的字段注入，如果在单实例Bean中注入Prototype类型的Bean，会因为Bean的实例化顺序不同的问题而报错。

| `singletonObjects`      | 一级缓存，存放完整的 Bean。                                  |
| ----------------------- | ------------------------------------------------------------ |
| `earlySingletonObjects` | 二级缓存，存放提前暴露的Bean，Bean 是不完整的，未完成属性注入和执行 初始化（init） 方法。 |
| `singletonFactories`    | 三级缓存，存放的是 Bean 工厂，主要是生产 Bean，存放到二级缓存中。 |

> Spring配置类中所有的@Bean都是代理对象？