# 类加载过程

java编译器将Java源文件编译成脱离平台的class字节码文件。

类加载器将这些class文件加载进JVM。JVM类加载过程分为几个阶段，分别是**加载**、**验证**、**准备**、**解析**和**初始化**。

- **加载**是把二进制字节码载入内存。
- **验证**是校验字节流中包含的信息是否符合当要求。
- **准备**是为静态变量分配内存并设置静态变量初始值。
- **解析**是把常量池内的符号引用替换为直接引用。
- **初始化**是执行所有静态变量的赋值动作和静态语句块中的语句。

## 类的生命周期

![image-20200821135619381](https://raw.githubusercontent.com/MatubCA/Image/main/img2/202208211356395.png)



## 一、加载

类加载主要完成下面三件事：

1. 通过全类名获取定义此类的二进制字节流
2. 将字节流所代表的静态存储结构转换为方法区的运行时数据结构
3. 在内存中生成一个代表该类的 `Class` 对象，作为方法区这些数据的访问入口

总结：**加载二进制数据进内存** ----> **映射成JVM能识别的结构** ----> **在内存中生成class文件**

## 二、验证

验证的作用：

- 确保class文件中的字节流包含的信息，符合当前虚拟机的要求。
- 保证这个被加载的class类的正确性，不会危害到虚拟机的安全。

![image-20220821143359386](https://raw.githubusercontent.com/MatubCA/Image/main/img2/202208211433418.png)

## 三、准备

准备的作用：

**准备阶段是正式为类变量分配内存并设置类变量初始值的阶段**，这些内存都将在方法区中分配

注意：

1. 这时候进行内存分配的仅包括类变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。
2. 从概念上讲，类变量所使用的内存都应当在 **方法区** 中进行分配。JDK 7 之前，HotSpot 使用永久代来实现方法区的时候，实现是完全符合这种逻辑概念的。而在 JDK 7 及之后，HotSpot 已经把原本放在永久代的字符串常量池、静态变量等移动到堆中，这个时候类变量则会随着 Class 对象一起存放在 Java **堆**中。
3. 被final修饰的static字段不会设置初始值，**因为final在编译的时候就分配了**

## 四、解析

解析的作用：

解析阶段的目的，是将常量池内的**符号引用**转换为**直接引用**的过程

符号引用和直接引用：

- 符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符 7 类符号引用进行。

  举例：

  比org.simple.People类引用了org.simple.Language类，在编译时People类并不知道Language类的实际内存地址，因此只能使用符号org.simple.Language（假设是这个，当然实际中是由类似于CONSTANT_Class_info的常量来表示的）来表示Language类的地址。

- 直接引用：直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。

## 五、初始化

初始化的作用：

执行类的构造方法 `<clinit> ()`的过程

 `<clinit> ()`的作用：

这个方法不需要定义，是javac编译器自动收集类中所有 **类变量的赋值动作和静态代码块中的语句** 合并来的。`jvm`会保证父类的 `<clinit> ()`先执行，然后在执行子类的 `<clinit> ()`。

类初始化的前提（**只有主动去使用类才会初始化类**）：

1. 当遇到 `new` 、 `getstatic`、`putstatic` 或 `invokestatic` 这 4 条直接码指令时。
2. 使用 `java.lang.reflect` 包的方法对类进行反射调用时如 `Class.forname("...")`, `newInstance()` 等等。如果类没初始化，需要触发其初始化。
3. 初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。
4. 当虚拟机启动时，用户需要定义一个要执行的主类 (包含 `main` 方法的那个类)，虚拟机会先初始化这个类。
5. `MethodHandle` 和 `VarHandle` 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用， 就必须先使用 `findStaticVarHandle` 来初始化要调用的类。
6. 当一个接口中定义了 JDK8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。

## 六、卸载

即该类的Class对象被垃圾回收器回收。

卸载类需要满足的三个要求：

1. **该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。**
2. **该类没有在其他任何地方被引用**
3. **该类的类加载器的实例已被 GC**

所以，在 JVM 生命周期内，由 jvm 自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。

