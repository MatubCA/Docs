# 类加载器

## 一、类加载器的作用

JVM 在加载 class 字节码文件时，会为每个字节码文件（Class对象），分配一个类加载器，作用就是：**将 class文件加载进内存**。并且所有的类都由类加载器加载。在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。

// TODO 数组

## 二、类加载器的分类

JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自`java.lang.ClassLoader`

![image-20220821194444348](https://raw.githubusercontent.com/MatubCA/Image/main/img2/202208211944387.png)

1. 启动类（引导类）加载器
   - 最顶层的加载类，这个类加载器使用 **C/C++** 语言实现的，嵌套在 JVM 内部，java 程序无法直接操作这个类。负责加载 **Java 核心类库**，用于提供 jvm 运行所需的包。
   - 并不是继承自 `java.lang.ClassLoader`，它没有父类加载器
   - 负责加载 `%JAVA_HOME%/lib`目录下的 jar 包和类或者被 `-Xbootclasspath`参数指定的路径中的所有类。

2. 扩展类加载器
   - 派生继承自 java.lang.ClassLoader，父类加载器为`启动类加载器`
   - 主要负责加载 `%JRE_HOME%/lib/ext` 目录下的 jar 包和类，或被 `java.ext.dirs` 系统变量所指定的路径下的 jar 包。

3. 应用程序类加载器
   - 派生继承自 java.lang.ClassLoader，父类加载器为`启动类加载器`
   - 它是程序中默认的类加载器，我们 Java 程序中的类，都是由它加载完成的。
   - 负责加载当前应用 classpath 下的所有 jar 包和类。
   - 可以通过 `ClassLoader#getSystemClassLoader()` 获取并操作这个加载器

4. 自定义类加载器
   -  用户自定义的类加载器,可加载指定路径的class文件
   - 当上述三种类加载器不满足我们要求时，我们可以开发自定义类加载器

## 三、自定义类加载器

除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自`java.lang.ClassLoader`。所以自定义类加载器需要继承 `ClassLoader`

- 不打破双亲委派：重写 `findClass()`
- 打破双亲委派：重写 `loadClass()`

## 四、双亲委派模型

### 什么是双亲委派模型？

**当一个类加载器收到了类加载的请求的时候，他不会直接去加载指定的类，而是把这个请求委托给自己的父加载器去加载。只有父加载器无法加载这个类的时候，才会由当前这个加载器来负责类的加载。**

举例：

比如一个定义在 `java.lang` 包下的类，因为它被存放在 `rt.jar`（**%JAVA_HOME%/lib** 目录下）之中，所以在被加载过程汇总，会被一直委托到 Bootstrap ClassLoader，最终由 Bootstrap ClassLoader所加载。

而一个用户自定义的 com.hollis.ClassHollis 类，他也会被一直委托到 `Bootstrap ClassLoader`，但是因为 Bootstrap ClassLoader 不负责加载该类，那么会在由 `Extention ClassLoader` 尝试加载，而 Extention ClassLoader 也不负责这个类的加载，最终才会被 `Application ClassLoader` 加载。

### 双亲委派模型的好处

1. 首先，**通过委派的方式，可以避免类的重复加载**，当父加载器已经加载过某一个类时，子加载器就不会再重新加载这个类。
2. 另外，**通过双亲委派的方式，还保证了安全性**。因为 Bootstrap ClassLoader 在加载的时候，只会加载 `JAVA_HOME` 中的 jar 包里面的类，如 java.lang.Integer，那么这个类是不会被随意替换的，除非有人跑到你的机器上， 破坏你的 JDK。那么，就可以避免有人自定义一个有破坏功能的 java.lang.Integer 被加载。这样可以有效的防止核心Java API被篡改。
3. 自底向上检查类是否被加载；自顶向下尝试加载类。

### 双亲委派源码

//TODO









